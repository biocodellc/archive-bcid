package temporarytests;

import bcid.CheckDigit;
import bcid.encoderBCID;
import bcid.minterBCID;
import org.junit.BeforeClass;
import org.junit.Test;

import java.math.BigInteger;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

/**
 * Suite of tests for BCIDs
 */
public class BCIDTest {

    private static minterBCID minter;
    static String startString;
    static String startStringWithCheckDigit;
    static BigInteger bigIntegerForStartString;
    CheckDigit checkDigit = new CheckDigit();


    /**
     * setUp Unit tests for BCID stuff
     */
    @BeforeClass
    public static void setUp() {
        try {
            //minter = new bcidMinter("ark:/99999/",new EmailAddress("foo@google.com"));
            minter = new minterBCID();
        } catch (Exception e) {
            e.printStackTrace();
        }
        startString = minter.getPrefix() + "O5rKAg";
        startStringWithCheckDigit = minter.getPrefix() + "O5rKAgN";
        bigIntegerForStartString = new BigInteger("1000000002");
    }

    /**
     * Test checkDigit Creation
     */
    @Test
    public void checkDigitCreation() {
        String stringWithCheckDigit = checkDigit.encode(startString);
        // The stringWithCheckDigit should come out as we expect
        assertTrue(stringWithCheckDigit.equals(startStringWithCheckDigit));
        // The stringWithCheckDigit should verify
        try {
            assertTrue(checkDigit.verify(stringWithCheckDigit));
        } catch (Exception e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
    }

    /**
     * Verify that the check digit actually catches bad digits.  We do this by looping through the
     * String 500 times and replace bad characters at various spots.  The % of false positives should
     * be less than 10%
     */
    @Test
    public void verify() {

        int cnt2 = 1;
        int totalcount = 0;
        int numBogusValidations = 0;
        StringBuilder sbCheckedString = new StringBuilder(startStringWithCheckDigit);
        while (cnt2 < 10) {
            int cnt = 65;
            while (cnt < 122) {
                sbCheckedString.setCharAt(cnt2, (char) cnt);
                String badString = sbCheckedString.toString();
                try {
                    if (checkDigit.verify(badString) && !badString.equals(startStringWithCheckDigit)) {
                        numBogusValidations++;
                    }
                } catch (Exception e) {
                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                }
                cnt++;
                totalcount++;
            }
            cnt2++;
        }
        float percentBogus = (numBogusValidations * 100.0f) / totalcount;
        assertTrue(percentBogus < 10);
    }


    /**
     * We need to be able to pass in Arks and decode the proper integer value for this ark
     * This set of tests checks to see that the decode functions in bcidMinter are working properyl
     */
    @Test
    public void decode() {
        // A simple check to decode a value -- this one throws an exception
        // e.g. ark:/99999/O5rKAg
        try {
            assertTrue(new encoderBCID(minter.prefix).decode(startStringWithCheckDigit).equals(bigIntegerForStartString));
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Check to see if we can decode something with a local Identifer appended to the end
        // e.g. ark:/99999/O5rKAg/MBIO0056
         try {
            assertTrue(new encoderBCID(minter.prefix).decode(startStringWithCheckDigit + "/MBIO0056").equals(bigIntegerForStartString));
        } catch (Exception e) {
            e.printStackTrace();
        }

        // See if an  exception is thrown when the String to check is bad, here we prepend "0" to an otherwise
        // good string
        try {
            new encoderBCID(minter.prefix).decode("0" + startStringWithCheckDigit);
            fail("Expected exception not thrown");
        } catch (Exception e) {
        }

        // Loop a bunch of possible input & output values, input value "i" should equal decoded value
        // (after going through encoding/decoding process)
        try {
            Integer i = 1000000000;
            while (i < 1000000005) {
                String encodedValue = new encoderBCID(minter.prefix).encode(new BigInteger(i.toString()));
                String decodedValue = new encoderBCID(minter.prefix).decode(encodedValue).toString();
                assertTrue(i.toString().equals(decodedValue));
                i++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

}


